Author: Jingning Qian id:1358068

Problems: Superheroes is not leaving the mansion before professor Z enter the mansion. (Dead lock, fixed)

Description: If the superhero who got a mission wants to leave the mansion the moment 	professor Z enters the mansion, their thread will be stuck. And because they do not leave the 	mansion, the semaphore which makes sure all the superheroes in the mansion should be in the 	secret room when professor Z enters cannot be updated. In this case, the meeting cannot start 	until that superhero leaves the mansion which causes dead lock.

Solution: I set the condition at the top of the block of ‘superheroleaveMansion’ method. If professor Z in the mansion and the superhero number in mansion is not equal to the superhero 	number in the secret room, then decrease by one for ‘superheroInMansion’ variable. This 	condition only satisfies the problem condition I presented.



Observation of behaviours

All mentioned behaviors are included. I also made some improvements to reach a good performance.

Consumer: it will not start its operation until the completed roster is empty. It also will generate random integer for index to specify the completed mission which was about to be removed.

Producer: For the sake of reality-driven, I monitor new mission list to wait for consuming mission when the mission amount above 10. In this case, the producer will not keep generating new missions all the time because of less sleep duration.

Superhero: Superhero has the most activities to do compared to other threads. They should enter the mansion first and have a chat with other superheroes. Then they are able to enter the secret room or just stay outside of the room. When professor Z enters the mansion, all the superheroes in the mansion should also enter the secret room. Once the meeting begins, they can acquire or release the mission if they have finished it. And then they should leave the secret room but not allowed to leave the mansion until professor Z leaves the mansion.

Professor Z: His behavior affects importantly to superheroes’ behavior. Professor Z should enter the mansion first and start the meeting after all superheroes enter the secret room. Then ends the meeting after all the superheroes leave the secret room. Finally leave the mansion.



Critical design

1. SuperheroInRoom / superheroInMansion semaphores

	Solved the problem that how to trigger the meeting begin. That is, every time the value of these 	two semaphores is equal, the meeting will begin. Otherwise, it will be in the non-runnable state 	waiting to be notified.

2. Mission property for superhero class

	A prefect connection between superheroes and roster. Each superhero wants their mission 	details to do roster operation. Their mission details are recorded after they acquired the 		mission.

3. Using random package to choose a random mission get acquired or removed instead of deleting one by one

	This idea is designed to simulate real-world operation.



Insight from experimenting with simulator

1. NotifyAll() can only notify the thread that is waiting on the monitor class where the 'notifyAll()' being called is. I wrote acquire and release function for superhero in Mansion class before and made some changes for shared data. However, I found that consumer and producer still waiting to be notified even though the data has updated. The reason is both call the method in Roster class instead of Mansion class, which means it never receive notify from other monitors no matter how I try to notify these two threads in Mansion class.

2. The code for each thread just needs to follow the logical behavior order, for the superheroes, for example, the behavior order is 1. enter the mansion. 2. have a chat with other superheroes. 3. enter the secret room. 4. acquire or release room when meeting begin. 5. leave the secret room. 6. leave the mansion. And each behavior will be implemented in each single function in the monitor class. We monitor and control these atomic events to make the behavior of the superhero more complex and unpredictable. This structure is understandable and feasible so that I can deal with all the thread problems by using it.

3. For producer and consumer, we need to do the boundary analysis for each of them in case of bounded problem or stack overflow.